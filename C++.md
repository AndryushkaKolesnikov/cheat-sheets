Вывод сообщения
cout << “Выводимое сообщение”;
Ввод данных
cin >> переменная;
Предложение if
If (условие) предложение;
else предложение
Цикл for
fоr(инициализация; условие; приращение) предложение;
Функция abs() принимает один apryмeнт, преобразует eгo в абсолютное значение и возвращает результат.
![alt text](image.png)
Модификаторы типов данных перечислены ниже: 
1)	¬signed (со знаком) 
2)	unsigпed (без знака) 
3)	long (длинный) 
4)	short (короткий)
![alt text](image-1.png)
![alt text](image-2.png)
Инициализация переменной
тип переменная = значение;
![alt text](image-3.png)
Операторы отношения
Оператор	Значение
>	Больше чем
>=	Больше чем или равно
<	Меньше чем
<=	Меньше чем или равно
==	равно
!=	Не равно
Операторы логические
Оператор	Значение
&&	И
||	ИЛИ
!	НЕ
True 1, false 0
p	q	p И q	p ИЛИ q	НЕ p
Ложь	Ложь	Ложь	Ложь	Истина
Ложь	Истина	Ложь	Истина	Истина
Истина	Истина	Истина	Истина	Ложь
Истина	Ложь	Ложь	Истина	Ложь
Приведение типа
(тип) выражение
Цепочка if..else..if
if(условие) 
предложение; 
else if(условие) 
предложение; 
else if(условие) 
предложение;
…
else предложение;
Предложение Switch
switсh(выражение) { 
case константа 1: 
последовательность предложений 
break; 
case константа2: 
последовательность предложений 
break; 
case константа3: 
последовательность предложений 
Ьreаk; 
¬	default: 
последовательность предложений 
¬}
Цикл for
fоr(инициализация; выражение; приращение) 
{ 
последовательность предложений 
}
Цикл while
whilе(выражение) предложение;
Цикл do-while
do{ 
предложения; 
} whilе(условие);
Если внутри цикла встречается предложение break, цикл немедленно завершается.
Сущеcrвует возможность принудительно завершить некoтoрый шar цикла, обойдя нормальную управляющую структуру цикла. Эro дейcтвие  выполняется с помощью предложения сопtinue.
Предложение С++ goto реализует безусловный переход
х = 1; 
loop1: ¬ 
Х++; 
if(x < 100) goto loop1;      //  Выполнение передается в точку loop 1.
¬Общая форма объявления одномерноrо массива:
¬тип имя[размер];
Общая форма обЪявления двумерного массива:
тип имя[размер1][размер2];
общая форма объявления многoмepнoro массива:
тип имя [размер 1] [размер2]... [размерN];
Основы техники строк
char str[размер];
Некоторые библиотечные функции обработки строк
strсру(куда ,откуда)
Функция strcpy( ) копирует содержимое строки откуда в строку куда.
strcat(s1 ,s2);
Функция strcat( ) присоединяет строку s2 к концу s1; строка s2 остаётся без изменений.
¬strсmp(s1 ,s2);
Функция strcmp() сравнивает две строки и возвращает О, если они равны.
strlen(s);
Здесь s ¬ это строка. Функция strlen() возвращает длину строки, на которую указывает s.
библиотечная функция toupper( ), которая возвращает прописной эквивалент cвoeгo символь¬нoгo арryмента, чем и осуществляется преобразование всех символов строки. Функция toupper( ) использует заrоловок <cctype>.
Фнкция tolower( ), преобразует прописные символы в их строчные эквиваленты.
Инициализация массивов
тип имя¬-массива[Pазмер] = {спuсок ¬значений через запятую};
Общая фор¬ма объявления переменной-¬указателя такова: 
¬тип *имя-¬переменной;
Для использования с указателями предусмотрены два специальных оператора: * и &. Оператор & является унарным; он возвращает адрес памяти, в которой расположен его операнд. Второй оператор, *, в не котором роде обратный по отношению к &. Этот унарный оператор возвращает значение переменной, располо¬женной по адресу, который указан в качестве операнда этого операто¬ра.
Все функции с++ имеют общую форму, приведенную ниже: 
¬тип¬-возврата имя(список¬-параметров) 
{ 
¬/ / тело функции 
¬}
Передача функции указателя. 
¬#include <iostream> 
using namespace std; 
¬void f (int *j); 
¬int main () 
{ 
¬int i; 
¬f(&i); ¬ 
¬cout << i; 
¬return 0; 
¬} 
¬void f(int *j) 
{ 
¬*j = 100; / / переменной, на которую указывает j, 
// теперь присвоено значение 100 
¬}
Передача массива в функцию
#include <iostream> 
using namespace std; 
¬void display (int nиm[10]) ; 
¬int main( ) 
{ 
¬int t[10], i; 
¬for(i=0; i < 10; ++i) t[i]=i; 
¬display (t); / / передача в функцию массива t 
¬return 0; 
¬} 
¬// Выведем несколько чисел. 
void display (int num[10] ) ¬ 
{ 
 int i; 
¬for(i=O; i < 10; i++) cout << num[i] << “  “; 
¬}
Рекурсия, иноrда называемая циклическим определением, представляет собой процесс определения чеrо¬то с помощью caмoro себя. В приложении к проrpаммированию рекурсия - это процесс вызова функцией самой себя. Функцию, которая вызывает саму себя, Ha¬зывают рекурсивной.
Const
Если переменная объявлена с описателем const, ее значение не может быть изменено в процессе выполнения прогpаммы.
Volatile
Описатель volatile сообщает компилятору, что значение переменной может изменяться, хотя в прогpамме нет предложений, явным образом модифицирующих эту переменную.
Auto
Описатель auto объявляет локальную переменную. Он, однако, ис¬пользуется редко (если вообще используется), потому что локальным переменным описатель auto назначается по умолчанию.
Extern
Объявление всех глобальных переменных в одном файле и их использование в других повторных объявлениях с ключевым словом extern.
Ключевое слово extern предоставляет возможность задавать спецификацию компоновки, которая представляет собой инструкцию для компилятора относительно того, как функция должна обрабатываться компоновщиком.
extern "язык" прототип¬-функции
Static
Коrда локальной переменной придается описатель static, для нее выделяется постоянная память практически так же, как и для rглобальных переменных. Это позволяет статической переменной сохранять свое значение при повторных обращениях из функций.
Когда описатель static придается глобальной переменной, компи¬лятор создает глобальную переменную, известную только в том файле, в котором эта переменная объявлена.
Register
Этот описатель требует от компилятора сохранить переменную таким образом, чтобы к ней можно было обращаться с максимальной скоростью.
Enum
в С++ вы можете определить список именованных целочисленных констант.
еnum имя-¬типа {список-¬значений} cписок-переменных;
typedef
С++ позволяет вам определять новые имена типов данных с помо¬щью ключевого слова typedef. 
Побитовые операторы
&	И
|	ИЛИ
^	Исключающее ИЛИ
~	Дополнение до единицы, НЕ
>	Сдвиг вправо
<	Сдвиг влево
Операторы сдвига, >> и <<, сдвиrают все биты переменной вправо или влево на указанное число битов. Общая форма оператора сдвиra вправо: 
¬переменная >> чuсло-¬бuтов 
¬Общая форма оператора сдвиrа влево: 
¬nеременная << чuсло¬-бuтов
Оператор ?
Eгo общая форма: 
¬Ехр1 ? Ехр2 : ЕхрЗ;
Значение выражения ? определяется следующим образом. Оценива¬ется выражение Ехр1. Если оно истинно, тоrда выражение Ехр2 вычис¬ляется и становится значением вceгo выражения? Если же Ехр1 ложно, тогда выражение ЕхрЗ вычисляется и становится значением вceгo выpa¬жения?
Sizeof
sizeof (тип) 
sizeof имя¬-переменной 
¬Первый вариант возвращает размер указанноrо типа данных, а второй ¬ размер указанной переменной.
Общая форма класса
class имя-¬класса { 
закрытые данные и функции 
public: 
открытые данные и функции 
} список обьектов;
Оператор точка
Форма:   объект.член
Общая фор¬ма конструктора выrлядит так:
имя¬-класса() { 
//код конструктора 
}
Общая фор¬ма деструктора выrлядит так:
~имя-¬класса() { 
//код конструктора 
}
Встроенные функции - это функция, которая фактически не вызывается, а развертывается в свой полный текст в месте cвоего¬ вызова. Встроенную функцию можно создать двумя способами. Первый заключается в использовании описателя inline:
inline int f () 
{ 
¬// ... 
¬}
Дрyrой способ создания встроенной функции заключается в опре¬делении кода функции¬-члена внутри определения класса. Любая функция, определенная внyrpи определения класса, автоматически делается встроенной.
Указатели на объекты
Вы можете обратиться к объекту либо непосредственно, либо посредством указателя на этот объект. При обращении к конкретному элементу объекта посред¬ством указателя на объект вы должны использовать оператор-¬стрелку: ->.
P¬_example оb, *р;   // объявим объект и указатель на него
р = &оb; / / присвоим р значение адреса оb
p¬>set_num(20); // вызов функции посредством указателя на оb
Создание и использование конструктора копий
Коuда объект передается в функцию, создается побитовая (т. е. точная) копия этого объекта, которая становится па¬раметром, принимающим объект. Однако имеются случаи, когда такая идентичная копия нежелательна. Например, если объект использует ресурс, скажем, открытый файл, тогда копия будет использовать тот же самый ресурс, что и исходный объект. В результате если копия как то изменяет ресурс, он будет изменен также и для исходного объекта!
Наиболее общая форма конструктора копий выrлядит так: 
имя¬-класса (const имя¬-класса& объект) { 
//тело конструктора 
}
Дружественные функции
Однако имеется возможность организовать доступ к закрытым членам класса из функции, не входящей в данный класс, посредством объявления ее другом класса. Чтобы сделать функцию 
дpyrом класса (создать дружественную классу функцию), вы включае¬те ее прототип в открытую (pubIic) секцию объявления класса и пред¬варяете ее ключевым словом friend. Например, в приведенном ниже фрагменте функция fmd() объявлена дpyгом класса MyClass: 
¬class MyClass { 
// ... 
public: 
friend void frnd (MyClass оb) ; 
// …
} ;
Структуры
В С++ единственное различие между class и struct заключается в том, что по умолчанию все члены в struct открыты, а в class закрыты. Во всех остальных отношениях структуры и классы эквивалентны.
Объединения
Объединение представляет собой область памяти, совместно исполь¬зуемую двумя или большим числом переменных. Объединение созда¬ется посредством ключевоrо слова union, и его объявление схоже с объ-явлением структуры, как это показано в следующем примере: 
¬union utype { 
short int i; 
char сb; 
} ;
Если объединение безымянно, то к его элементам можно обращаться как к обычным локальным переменным.
Перегрузка операторов
Когда вы перегpужаете оператор, вы определяете смысл этого опе¬ратора для конкретного класса.
Общая форма функции operator выглядит так: 
¬тип имя -класса: :operator# (список-аргументов) 
{ 
/ /операции 
} 
Здесь перегpужаемый оператор должен заместить знак #, а тип ¬ это тип значения, возвращаемого определяемой операцией.
Основы наследования
Общая форма наследования ориведена ниже: 
¬class производный-класс : доступ базовый-класс { 
/ / тело производного класса 
}
Protected
Коrда базовый класс наследуется с атрибутом pubIic, защищенные члены базовоro класса становятся защищенными членами производ¬нoгo класса. Коrда базовый класс наследуется с атрибутом private, за-щищенные члены базовоrо класса становятся закрытыми членами производноrо класса.
Поэтому наиболее распространенная полная форма объявления класса выглядит таким образом:
class имя-¬класса { 
/ / закрытые члены класса 
protected: 
/ / защищенные члены 
public: 
/ / открытые члены 
};
Вызов конструктора базового класса
Производный класс может вызывать конструктор, определенный в базовом классе, по¬ средством расширенной формы объявления конструктора производ¬ногo класса. Общая форма этого расширенного объявления выrля¬дит так: 
¬производный¬-конструктор (cписок-аргументов) : базовый¬-конструктор (список-аргументов) 
{ 
тело конструктора производного класса 
}
Основы виртуальных функций
Виртуальной называется функция, объявленная в базовом классе с описателем virtual и переопределенная в одном или нескольких произ¬водных классах.
Чистая виртуальная функция - это функция, объявленная в базо¬вом классе и не имеющая в этом классе cвoero определения. В этом случае каждый производный класс должен обязательно определить собственный вариант функции - он не может использовать функцию, которая не имеет определения. Для объявления чистой виртуальной функции используется такая общая форма: 
¬virtual тип имя¬-функции(список-¬параметров) = 0;
Создание операторных функций вывода
шаблон для функции вывода: 
¬ostream &operator<<(ostream &stream, class¬t_type obj) 
{ 
// здесь располаrается код, специфический для данноrо 
// класса 
return stream; // возврат stream 
¬}
Переrрузка операторов ввода
Шаблон для переrpуженного оператора ввода выrлядит так: 
¬istream &operator>>(istream &stream, object¬_type &obj) 
{ 
// здесь размещается код вашей функции ввода
return stream;
¬}
Форматирование с помощью функций¬-членов ios
с помощью этих значений устанавливаются и сбрасываются фла¬ги формата. Некоторые старые компиляторы могyт не распознавать перечислимый тип fmtt1ags; в этом случае флаги формата кодируются в виде длинных целых чисел. 
Если флаг skipws установлен, то при вводе в поток отбрасываются ведущие пробельные символы. Если флаr skipws сброшен, то пробельные символы не отбра¬сываются. 
Если флаг left установлен, то вывод выравнивается по левому краю. 
Если установлен right, вывод выравнивается по правому краю. 
При установке флага intemal числовые значения дополняются пробелами до указанной ширины поля, причем пробелы включаются между знаком числа и самим числом. Если ни один из этих флагов не установлен, вывод по умолчанию выравнивается по правому краю. 
Числовые значения выводятся по умолчанию в десятичной форме. 
Однако имеется возможность изменить систему счисления. Установка флага oct приводит к выводу чисел в восьмеричной системе; флаг bех устанавливает шестнадцатеричную систему, а для возврата к десятич¬ной форме вывода надо установить флаг dec. 
Установка showbase включает в вывод обозначение системы счисле¬ния. Например, если установлена шестнадцатеричная система вывода, то значение 1F будет отображаться как Ox1F: 
Если вывод чисел осуществляется в экспоненциальной форме, то по умолчанию выводится строчное е. Кроме того, строчной будет бук¬ва х при выводе шестнадцатеричных чисел. Если установить флаг uppercase, эти символы выводятся прописными буквами. 
Установка showpos выводит знак плюс перед положительными зна¬чениями. 
Установка showpoint приводит к выводу десятичной точки и завер¬шающих нулей при выводе любых чисел с плавающей точкой, даже если в этом нет фактической необходимости. 
При установке флaгa scientific числа с плавающей точкой будyт выводиться в экспоненциальной форме. Если установлен tixed, числа с пла¬вающей точкой выводятся обычным образом. Если ни один из этих фла¬гов не установлен, компилятoр сам выбирает подходящий способ вывода. 
¬Если установлен unitbuf, после каждой операции вставки буфер очи¬щается. 
При установленном boolalpha булевы переменные вводятся и выводятся с использованием ключевых слов true и false. 
Поскольку часто приходится ссылаться на поля oct, dec и Ьех, для их совокупности введено обозначение basefield. Аналоrично поля left, right и intemal обозначаются adjustfield. Наконец, к полям scientific и fixed можно обращаться с помощью ключевоrо слова floatfield.
Установка и сброс флагов формата
fmtflags setf(fmtflags флаги);
Например, чтобы установить флаг showbase, следует использовать такое предложение: 
¬поток.sеtf(iоs::shоwbаsе); 
¬Здесь поток¬ это тот поток, на который вы хотите воздействовать.
для сброса флаrов используется функция unsetf( ) со следующим прототипом: 
¬void unsetf(fmtflags флаги);
Вы можете определить текущие значения флaгов с помощью 
функции flaga( ) со следующим прототипом: 
¬fmtflags flags( ); 
¬Эта функция возвращает текущее значение флагов в вызвавшем ее потоке. 
Дрyгая форма той же функции устанавливает флaг, заданный пара¬ метром флаги, и возвращает предыдущее значение этоrо флaга: 
¬fmtflags flags(fmtflags флаги);
Установка ширины поля
streamsize width(streamsize w); 
¬Здесь w становится шириной поля, а возвращаемое значение представляет собой предыдущее значение ширины.
Установка точности при выводе значений с плавающей точкой в экспоненциаль¬ной форме вы можете задать число цифр, выводимых после десятичной точки, с помощью функции precision( ). Ее прототип выrлядит так: 
¬streamsize precision(streamsize р); 
¬Здесь число цифр (точность) устанавливается равным р, и функция возвращает старое значение.
По умолчанию, если поле нуждается в заполнении, оно заполняет¬ся пробелами. С помощью функции till() вы можете задать символ-¬за¬полнитель. Прототип этой функции: 
¬char fill( char ch); 
¬После вызова ffll() сh становится новым символом-¬заполнителем, а старое значение возвращается функцией.
Все манипуляторы ввода без параметров имеют такой шаблон:
istream &manip¬_name(istream &stream) 
{ 
// ваш код размещается здесь 

¬return stream; 
¬}
Открытие и закрытие файл
Библиотека <fstream>
ifstream in; //  создание потока ввод 
ofstream out; // создание потока  вывод 
fstream both; // создание потока ввод и вывод
Создав поток, вы можете связать его с файлом с помощью функции ореn().
Следующий фраrмент открывает текстовый файл для вывода: 
¬ofstream mystream;
mystream.ореn ("test”) ;
Если функция ореп( ) завершилась неуспешно, поток, если ero ис¬пользовать в булевом выражении, примет значение false. Вы можете использовать это обстоятельство для подтверждения успешноrо открытия файла с помощью предложения тaкoгo рода: 
¬if ( !mystream) { 
cout << "Не мory открыть файл. \n" ; 
// обработка ошибки 
¬}
ifstream mystream ("myfile"); / / открыть файл для ввода
Для закрытия файла используйте функцию-¬член close( ). Например, чтобы закрыть файл, связанный с потоком, который назван mystream, вы используете такое предложение: 
¬mystream.close();
Использование get( ) и put( )
istream &get( char &ch); 
ostream &put(char ch);
Функция get( ) читает один символ из связанноrо с файлом потока и помещает eгo значение в ch. Функция put() записывает.
Чтение и запись блоков данных
Для чтения и записи блоков двоичных данных используйте функ¬ции-¬члены read( ) и write( ). Они имеют такие прототипы: 
¬istream &read(char *bиf, streamsize num); 
ostream &write( const char * buf, streamsize num);
Функция read( ) читает пит байтов из потока, связанноrо с фай¬лом, и заносит их в буфер, на который указывает buf. Функция write( ) записывает пит байтов в поток из буфера, на который yкa¬зывает buf.  Как уже упоминалось, streamsize - это имя типа той или иной формы целоrо числа, определенный в библиотеке С++.
Узнать, сколько символов бьто прочитано, можно с помощью дрyrой Функ¬ции¬-члена, gcount( ), имеющий такой прототип: 
¬streamsize gcount( ); 
Функция gcount( ) возврашает число символов, прочитанных в по¬следней операции ввода.
getline( ). 
Она является членом класса потока ввода; ее прототипы выглядят так: 
¬istream &getline( char * buf, streamsize пит); 
istream &getline(char *buf, streamsize пит, char delim); 
¬Первый вариант читает символы в массив, на который указывает buf, до тех пор, пока не будет введено num - 1 символов, или обнару¬жен символ новой строки, или встретится конец файла.
Второй вариант читает символы в массив, на который указывает buf, до тех пор, пока не будет введено num - 1 символов, или обнару¬жится разделительный символ, заданный параметром delim, или встретится конец файла.
Обнаружение символа EOF
Для тогo, чтобы узнать, не достигнyт ли конец файла, можно ис¬пользовать функцию-член eof( ) со следующим прототипом: 
¬bool eof( ); 
¬Функция возвращает true, если был достиrнyт конец файла, и false в противном случае.
peek( ) и putback( )
 Int peek( ); 
¬peek() возвращает следующий символ в потоке или EOF если достиr¬нут конец файла. Символ содержится в младшем байте возвращаемого значения. 
Можно, наоборот, вернуть в поток последний прочитанный из него символ. Для этого используется функция putback( ). Ее прототип выrлядит так: 
¬istream &putback(char с); 
¬Здесь с - последний прочитанный символ.
flush( )
Вы можете принудительно сбросить содержимое буфера на диск, даже если он еще не заполнен, вызвав функцию flush( ). Ее прототип выглядит так: 
¬ostream &flush( );
Произвольный доступ
вы можете обращаться к произвольным местам файла в случайном порядке. В системе ввoдa¬вывoдa С++ произвольный доступ к файлу осуществляется с помощью функций seekg( ) и seekp( ). ИХ наиболее употребительные формы выглядят таким образом: 
¬istream &seekg( off_¬type offset, seekdir origiп); 
ostream &seekp(off¬_type offset, seekdir origiп); 
¬Здесь off_type ¬ это целочисленный тип, определенный в ios. Пере¬менные этого типа имеют длину, достаточную для размещения максимальноuj значения, которое может иметь offset. seekdir является пере¬числимым типом, который может принимать следующие значения:
Значение	Описание 
ios::beg	Начало файла
ios::cur	Текущая позиция
ios::end	Конец файла

Основы обработки исключений
try { 
/ / часть программы где отслеживаются ошибки
} 
catch (тип1 аргумент) { 
/ / блок catch 
} 
catch (тип2 аргумент) { 
/ / блок catch 
} 
catch (типЗ  аргумент) { 
/ / блок catch 
} 
// ... 
catch (muпN аргумент) { 
/ / блок catch 
}
Общая форма предложения throw выrлядит так: 
¬throw исключение 
¬Предложение throw выбрасывает исключение, указанное параметром исключение.
Улавливание всех исключений
в некоторых случаях вам может понадобиться обработчик исклю¬чений, который будет ловить все исключения, а не исключения одного определенного типа. Для построения тaкогo обработчика вы должны использовать следующую форму catch: 
¬catch(...) { 
/ /обработка всех исключений 
¬}
Задание исключений, выбрасываемых функцией
тип-возврата имя¬-функции(спuсок-аргументов) throw (спuсок-типов) 
{ 
¬	//... 
¬}
Родовая функция определяет обобщенный набор операций, которые будyr применены к различным типам данных. Общая форма определения родовой функции выrлядит так: 
¬template <class тип> тип-¬возврата имя¬-функции(список¬-параметров) 
{ 
¬/ /тело Функции 
¬}
Родовые классы
template <class тип> class имя¬-класса { 
/ / тело класса 
¬}
Здесь тип - это условное имя обобщенноrо, родовоrо типа, который будет задан при создании экземпляра класса. После тoro, как вы создали родовой класс, вы создаете конкретный экземпляр этого класса посредством следующей общей формы: 
¬имя¬-класса <тип> объект;
Динамическое выделение памяти
С++ предоставляет два оператора для динамического выделения памяти: new и delete. Оператор new вьделяет память и возвращает yкa¬затель на ее начало. Оператор delete освобождает память, предвари¬тельно выделенную посредством оператора new Общая форма этих операторов приведена ниже: 
¬p_¬var = new тип; 
delete р_var;
Здесь p_¬var представляет собой переменную-¬указатель, принимающую адрес памяти, объем которой достаточен для хранения элемента данных типа тип.
Вы можете инициализировать вьшеленную память каким-¬либо из¬вестным значением, указав значение--инициализатор после имени типа в предложении new Вот общая форма ne¬w если этот оператор ис¬пользуется вместе с инициализатором: 
¬p__var = new тип (инициализатор);
Вы можете выделить память под массив с помощью ne¬ используя следующую общую форму: 
¬p_¬var = new тип¬-мaccивa [размер];
Для освобождения памяти, выделенной под массив, следует использовать такую форму delete: 
delete [ ] р_var;
Основы использования пространств имен
По существу namespace определяет область видимости. Общая форма объявления пространства имен выrлядит таким образом: 
¬namespace имя { 
/ / объявления 
¬}
Обращение к элементам пространства имен
Имя-пространства-имен::элемент
Предложение using:
using namespace имя; 
using имя:: член;
Статические переменные-члены
Если вы предваряете объявление переменной-¬члена словом static, вы сообщаете компилятору, что может существовать только одна копия этой переменной, и что все объекты данноrо класса будут использовать эту единственную копию. Если вы объявляете данное-член вида static внутри класса, вы не определяете eгo. Вы обязаны выполнить rлобальное определе¬ние этой переменной rде-¬то в друrом месте, вне класса.
Динамическая идентификация типов (RТТI)
для получения типа объекта предусмотрен оператор typeid. Для ис¬пользования typeid необходимо подключить заroловок <typeinfo>. Чаще вcero используется такая форма этоrо оператора: 
¬typeid(объект)
Dynamic_cast
Оператор dynamic.....cast выполняет приведение типа во  время выполнения проrpаммы с контролем ero допустимости. Если в тот момент, когда выполняется dynamic_¬cast, приведение недопусти¬мо, оно не производится. Общая форма dynamic¬_cast выrлядит следующим образом: 
¬dynamic_¬cast <тип¬-мишени> (выражение)
#define
Директива #define используется для определения идентификатора, а также символьной последовательности, кoтoрой будет заменяться этот идентификатор каждый раз, коrда он будет встречаться в тексте проrpам¬мы. Идентификатор носит название имени макроса, а процесс замены Ha¬зывается макроподстановкой. Общая форма этой директивы такова: 
¬#define имя-¬макроса символьная-nоследовательность
#error
Директива #error, встретившись в тексте проrpаммы, заставляет компилятор прекратить компиляцию. Эта директива используется в основном в целях отладки. Общая ее форма такова: 
¬#error сообщение-¬об-¬ошибке
#include
Директива препроцессора #include требует, чтобы компилятор под¬ключил к тексту проrраммы, содержащей директиву #include, либо стандартный заголовок, либо другой файл с исходным текстом. Имя стандартного заголовка заключается в угловые скобки.ъ
#if, #eI5e, #elif и #endif 
¬Обшая идея, воплощенная в директиве #If, заключается в том, что если константное выражение, следующее за #if, истинно, тоrда код между ним и директивой #endif компилируется; в противном случае этот код опускается. Директива #епdif используется для тouo, чтобы отметить конец блока #if. Общая форма #if такова: 
¬#if выражение 
последовательность предложений 
#elif выражение 1 
последовательность предложений 
#elif выражение2 
последовательность предложений 
#elif выражение3 
последовательность предложений 
/ /... 
#elif выражениеN 
последовательность предложений 
#endif
#undef 
¬Директива  #undеf используется для тoro чтобы oтменить указанное ранее определение имени макроса. Общая форма эroй директивы такова: 
#undef uмя-макроса
#Iine 
¬Директива #line используется, чтобы изменить содержимое предо¬пределенных макросов ¬ ¬LINE¬ ¬ и ¬ ¬FILE¬ ¬. Макрос ¬ -LINE¬ ¬ содержит номер компилируемой строки, а макрос ¬ ¬FILE¬ ¬ содержит имя компилируемого файла. Основная форма директивы #Iine такова: 
¬#line число "имя¬файла" 
¬Здесь число представляет собой любое положительное целое.
Макрос ¬ ¬DATE¬ ¬ содержит строку в форме .месяц/день/год, которая представляет собой дату трансляции исходного текста в объектный код. 
Макрос ¬ ¬TIME¬ ¬ содержит время, когда npoгpaммa была откомпилирована. Время представлено в виде строки в формате час:мину¬та: секунда. 
Смысл макроса ¬ ¬STDC¬ ¬ зависит от реализации компилятора. 
Обычно если макрос ¬ ¬STDC¬ ¬ определен, компилятор будет воспринимать только стандартный код С/С++, не содержащий никаких нестандартных расширений.
